<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.1" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.1" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>




  
  <meta name="keywords" content="Flink," />


<meta name="description" content="Flink DataStream 应用程序所处理的事件以数据对象的形式存在。函数调用时会传入数据对象，同时也可以输出数据对象。因此，Flink 在内部需要能够处理这些对象。当通过网络传输或者读写状态后端、检查点以及保存点时，需要对它们进行序列化和反序列化。为了能够更高效的做到这一点，Flink 需要详细了解应用程序处理的数据类型。Flink 使用类型信息的概念来表示数据类型，并为每种数据类型生成特">
<meta name="keywords" content="Flink">
<meta property="og:type" content="article">
<meta property="og:title" content="Flink DataStream 类型系统 TypeInformation">
<meta property="og:url" content="http://smartsi.club/flink-datastream-typeinformation.html">
<meta property="og:site_name" content="SmartSi">
<meta property="og:description" content="Flink DataStream 应用程序所处理的事件以数据对象的形式存在。函数调用时会传入数据对象，同时也可以输出数据对象。因此，Flink 在内部需要能够处理这些对象。当通过网络传输或者读写状态后端、检查点以及保存点时，需要对它们进行序列化和反序列化。为了能够更高效的做到这一点，Flink 需要详细了解应用程序处理的数据类型。Flink 使用类型信息的概念来表示数据类型，并为每种数据类型生成特">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://github.com/sjf0115/ImageBucket/blob/main/Flink/flink-datastream-typeinformation-1.png?raw=true">
<meta property="og:image" content="https://github.com/sjf0115/ImageBucket/blob/main/Flink/flink-datastream-typeinformation-2.png?raw=true">
<meta property="og:image" content="https://github.com/sjf0115/ImageBucket/blob/main/Flink/flink-datastream-typeinformation-3.png?raw=true">
<meta property="og:image" content="https://github.com/sjf0115/ImageBucket/blob/main/Flink/flink-datastream-typeinformation-4.png?raw=true">
<meta property="og:updated_time" content="2022-04-21T14:28:57.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Flink DataStream 类型系统 TypeInformation">
<meta name="twitter:description" content="Flink DataStream 应用程序所处理的事件以数据对象的形式存在。函数调用时会传入数据对象，同时也可以输出数据对象。因此，Flink 在内部需要能够处理这些对象。当通过网络传输或者读写状态后端、检查点以及保存点时，需要对它们进行序列化和反序列化。为了能够更高效的做到这一点，Flink 需要详细了解应用程序处理的数据类型。Flink 使用类型信息的概念来表示数据类型，并为每种数据类型生成特">
<meta name="twitter:image" content="https://github.com/sjf0115/ImageBucket/blob/main/Flink/flink-datastream-typeinformation-1.png?raw=true">






  <link rel="canonical" href="http://smartsi.club/flink-datastream-typeinformation.html"/>


  <title>Flink DataStream 类型系统 TypeInformation | SmartSi</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SmartSi</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">专注大数据领域的小白</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />搜索</a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://smartsi.club/flink-datastream-typeinformation.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sjf0115">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SmartSi">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Flink DataStream 类型系统 TypeInformation</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-07T16:35:01+08:00">2022-04-07</time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2022-04-21T22:28:57+08:00">2022-04-21</time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Flink/" itemprop="url" rel="index"><span itemprop="name">Flink</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/flink-datastream-typeinformation.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/flink-datastream-typeinformation.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/flink-datastream-typeinformation.html" class="leancloud_visitors" data-flag-title="Flink DataStream 类型系统 TypeInformation">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Flink DataStream 应用程序所处理的事件以数据对象的形式存在。函数调用时会传入数据对象，同时也可以输出数据对象。因此，Flink 在内部需要能够处理这些对象。当通过网络传输或者读写状态后端、检查点以及保存点时，需要对它们进行序列化和反序列化。为了能够更高效的做到这一点，Flink 需要详细了解应用程序处理的数据类型。Flink 使用类型信息的概念来表示数据类型，并为每种数据类型生成特定的序列化器、反序列化器以及比较器。</p>
<p>此外，Flink 还有一个类型提取系统，可以分析函数的输入和返回类型来自动获取类型信息，进而获得序列化器和反序列化器。但是，在某些情况下，例如使用了 Lambda 函数或者泛型类型，必须显式提供类型信息才能使应用程序正常工作或者提高其性能。</p>
<p>在本文中，我们会讨论 Flink 支持的数据类型，如何为数据类型创建类型信息，以及如何在 Flink 的类型系统无法自动推断函数的返回类型时提供提示，最后简单说明一下显示指定类型信息的两个场景。</p>
<h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h2><p>Flink 支持 Java 和 Scala 所有常见的数据类型，也不需要像 Hadoop 一样去实现一个特定的接口（org.apache.hadoop.io.Writable），能够自动识别数据类型。使用最多的可以分为如下几类，如下图所示：</p>
<p><img src="https://github.com/sjf0115/ImageBucket/blob/main/Flink/flink-datastream-typeinformation-1.png?raw=true" alt=""></p>
<p>从图中可以看到 Flink 类型可以分为基本类型、数组类型、复合类型、辅助类型以及泛型。</p>
<h3 id="1-1-基本类型"><a href="#1-1-基本类型" class="headerlink" title="1.1 基本类型"></a>1.1 基本类型</h3><p>Flink 能够支持所有 Java 和 Scala 原生基本类型（包装类型）以及 Void、String、Date、BigDecimal、BigInteger 等类型。例如通过从给定的元素集中创建 DataStream 数据集：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"><span class="comment">// 创建 Integer 类型的数据集</span></span><br><span class="line">DataStream&lt;Integer&gt; integerElements = env.fromElements(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 创建 String 类型的数据集</span></span><br><span class="line">DataStream&lt;String&gt; stringElements = env.fromElements(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="1-2-数组类型"><a href="#1-2-数组类型" class="headerlink" title="1.2 数组类型"></a>1.2 数组类型</h3><p>数组类型包含两种类型：</p>
<ul>
<li>基本类型数组：基本类型的 Java 数组，支持 boolean、byte、short、int、long、float 等</li>
<li>对象数组：Object 类型的 Java 数组，支持 String 以及其他对象</li>
</ul>
<p>例如通过从给定的元素集中创建 DataStream 数据集：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] b = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">DataStream&lt;<span class="keyword">int</span>[]&gt; arrayElements = env.fromElements(a, b);</span><br></pre></td></tr></table></figure></p>
<h3 id="1-3-复合数据类型"><a href="#1-3-复合数据类型" class="headerlink" title="1.3 复合数据类型"></a>1.3 复合数据类型</h3><h4 id="1-3-1-Java-Tuples-类型"><a href="#1-3-1-Java-Tuples-类型" class="headerlink" title="1.3.1 Java Tuples 类型"></a>1.3.1 Java Tuples 类型</h4><p>Flink 在 Java 接口中定义了元组类（Tuple）供用户使用。元组是由固定数量的强类型字段组成的复合数据类型。如下代码所示，创建 Tuple 数据类型数据集：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataStream&lt;Tuple2&gt; tupleElements = env.fromElements(<span class="keyword">new</span> Tuple2(<span class="number">1</span>, <span class="string">"a"</span>), <span class="keyword">new</span> Tuple2(<span class="number">2</span>, <span class="string">"b"</span>));</span><br></pre></td></tr></table></figure></p>
<p>Flink 提供了 Java 元组的高效实现，最多包含 25 个字段，每个字段长度都对应一个单独的实现，即 Tuple0 到 Tuple25。如果字段数量超过上限，可以通过继承 Tuple 类的方式进行拓展。</p>
<h4 id="1-3-2-Scala-Case-Class-与-Tuple-类型"><a href="#1-3-2-Scala-Case-Class-与-Tuple-类型" class="headerlink" title="1.3.2 Scala Case Class 与 Tuple 类型"></a>1.3.2 Scala Case Class 与 Tuple 类型</h4><p>Flink 支持任意的 Scala Case Class 以及 Scala tuples 类型，支持的字段数量上限为 22，支持通过字段名称和位置索引获取指标，不支持存储空值。如下代码实例所示，定义 WordCount Case Class 数据类型，然后通过 fromElements 方法创建 input 数据集，调用 keyBy() 方法对数据集根据 word 字段重新分区。<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义WordCount Case Class数据结构</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span>(<span class="params">word: <span class="type">String</span>, count: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">通过fromElements方法创建数据集</span></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">input</span> </span>= env.fromElements(<span class="type">WordCount</span>(<span class="string">"hello"</span>, <span class="number">1</span>), <span class="type">WordCount</span>(<span class="string">"world"</span>, <span class="number">2</span>))</span><br><span class="line"><span class="keyword">val</span> keyStream1 = input.keyBy(<span class="string">"word"</span>) <span class="comment">// 根据word字段为分区字段，</span></span><br><span class="line"><span class="keyword">val</span> keyStream2 = input.keyBy(<span class="number">0</span>) <span class="comment">//也可以通过指定position分区</span></span><br></pre></td></tr></table></figure></p>
<p>通过使用 Scala Tuple 创建 DataStream 数据集，其他的使用方式和 Case Class 相似。需要注意的是，如果根据名称获取字段，可以使用 Tuple 中的默认字段名称：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 通过 scala Tuple 创建具有两个元素的数据集</span><br><span class="line">val tupleStream: DataStream[Tuple2[String, Int]] = env.fromElements((&quot;a&quot;, 1),(&quot;c&quot;, 2))</span><br><span class="line">// 使用默认字段名称获取字段，其中 _1 表示 tuple 的第一个字段</span><br><span class="line">tupleStream.keyBy(&quot;_1&quot;)</span><br></pre></td></tr></table></figure></p>
<h4 id="1-3-3-ROW-类型"><a href="#1-3-3-ROW-类型" class="headerlink" title="1.3.3 ROW 类型"></a>1.3.3 ROW 类型</h4><p>Row 是一种固定长度、可识别空值的复合类型，以确定的字段顺序存储多个值。每个字段的类型都可以不一样并且每个字段都可以为空。由于无法自动推断行字段的类型，因此在生成 Row 时都需要提供类型信息。如下代码所示，创建 Row 数据类型数据集：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataStream&lt;Row&gt; rowElements = env.fromElements(Row.of(<span class="number">0</span>, <span class="string">"a"</span>, <span class="number">3.14</span>));</span><br></pre></td></tr></table></figure></p>
<h4 id="1-3-4-POJO-类型"><a href="#1-3-4-POJO-类型" class="headerlink" title="1.3.4 POJO 类型"></a>1.3.4 POJO 类型</h4><p>Flink 会分析那些不属于任何一类的数据类型，尝试将它们作为 POJO 类型进行处理。如果一个类型满足如下条件，Flink 就会将它们作为 POJO 数据类型：</p>
<ul>
<li>POJOs 类必须是一个公有类，Public 修饰且独立定义，不能是内部类；</li>
<li>POJOs 类中必须包含一个 Public 修饰的无参构造器；</li>
<li>POJOs 类中所有的字段必须是 Public 或者具有 Public 修饰的 getter 和 setter 方法；</li>
<li>POJOs 类中的字段类型必须是 Flink 支持的。</li>
</ul>
<p>例如，如下 Java 类就会被 Flink 识别为 POJO：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (1) 必须是 Public 修饰且必须独立定义，不能是内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// (4) 字段类型必须是 Flink 支持的</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// (2) 必须包含一个 Public 修饰的无参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// (3) 所有的字段必须是 Public 或者具有 Public 修饰的 getter 和 setter 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义好 POJOs Class 后，就可以在 Flink 环境中使用了，如下代码所示，使用 fromElements 接口构建 Person 类的数据集:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">env.fromElements(<span class="keyword">new</span> Person(<span class="string">"Lucy"</span>, <span class="number">18</span>), <span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">12</span>))</span><br></pre></td></tr></table></figure></p>
<h3 id="1-4-辅助类型"><a href="#1-4-辅助类型" class="headerlink" title="1.4 辅助类型"></a>1.4 辅助类型</h3><p>在 Flink 中也支持一些比较特殊的数据数据类型，例如 Scala 中的 List、Map、Either、Option、Try 数据类型，以及 Java 中 Either 数据类型，还有 Hadoop 的 Writable 数据类型。如下代码所示，创建 List 类型数据集：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataStream&lt;ArrayList&lt;Integer&gt;&gt; listElements = env.fromElements(</span><br><span class="line">        Lists.newArrayList(<span class="number">1</span>, <span class="number">2</span>), Lists.newArrayList(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>这种数据类型使用场景不是特别广泛，主要原因是数据中的操作相对不像 POJOs 类那样方便和透明，用户无法根据字段位置或者名称获取字段信息，同时要借助 Types Hint 帮助 Flink 推断数据类型信息。</p>
<h3 id="1-5-泛型类型"><a href="#1-5-泛型类型" class="headerlink" title="1.5 泛型类型"></a>1.5 泛型类型</h3><p>那些无法特别处理的类型会被当做泛型类型处理并交给 Kryo 序列化框架进行序列化。如果可能的话，尽可能的避免使用 Kryo。Kryo 作为一个通用的序列化框架，通常效率不高。</p>
<h2 id="2-TypeInformation"><a href="#2-TypeInformation" class="headerlink" title="2. TypeInformation"></a>2. TypeInformation</h2><p>那这么多的数据类型，在 Flink 内部又是如何表示的呢？在 Flink 中每一个具体的类型都对应了一个具体的 TypeInformation 实现类。例如，BasicTypeInformation 中的 IntegerTypeInformation 对应了 Integer 数据类型。数据类型的描述信息都是由 TypeInformation 定义，比较常用的 TypeInformation 有 BasicTypeInfo、TupleTypeInfo、CaseClassTypeInfo、PojoTypeInfo 类等，如下图所示：</p>
<p><img src="https://github.com/sjf0115/ImageBucket/blob/main/Flink/flink-datastream-typeinformation-2.png?raw=true" alt=""></p>
<p>TypeInformation 为系统提供生成序列化器和比较器提供必要的信息。当应用程序提交执行时，Flink 的类型系统会尝试为处理的每种数据类型自动推断 TypeInformation。类型提取器会分析函数的泛型类型以及返回类型，来获取相应的 TypeInformation 对象。但是，有时类型提取器会失灵，或者你可能想定义自己的类型并告诉 Flink 如何有效地处理它们。在这种情况下，你需要为特定数据类型生成 TypeInformation。</p>
<p>除了对类型地描述之外，TypeInformation 还提供了序列化的支撑。每一个 TypeInformation 都会为对应的具体数据类型提供一个专属的序列化器。TypeInformation 会提供一个 createSerialize() 方法，通过这个方法就可以得到该类型进行数据序列化操作与反序列化操作的序列化器 TypeSerializer：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TypeSerializer&lt;T&gt; <span class="title">createSerializer</span><span class="params">(ExecutionConfig executionConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.serializer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于大多数数据类型 Flink 可以自动生成对应的序列化器，能非常高效地对数据集进行序列化和反序列化，比如，BasicTypeInfo、WritableTypeIno 等，但针对 GenericTypeInfo 类型，Flink 会使用 Kyro 进行序列化和反序列化。其中，Tuple、Pojo 和 CaseClass 类型是复合类型，它们可能嵌套一个或者多个数据类型。在这种情况下，它们的序列化器同样是复合的。它们会将内嵌类型的序列化委托给对应类型的序列化器。</p>
<h2 id="3-显示指定-TypeInformation"><a href="#3-显示指定-TypeInformation" class="headerlink" title="3. 显示指定 TypeInformation"></a>3. 显示指定 TypeInformation</h2><p>大多数情况下，Flink 可以自动推断类型生成正确的 TypeInformation，并选择合适的序列化器和比较器。Flink 的类型提取器利用反射分析函数签名以及子类信息，生成函数的正确输出类型。但是有时无法提取必要的信息，例如定义函数时如果使用到了泛型，JVM 就会出现类型擦除的问题，使得 Flink 并不能很容易地获取到数据集中的数据类型信息。这时候可能会抛出如下类似的异常：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; org.apache.flink.api.common.functions.InvalidTypesException: The return type of function &apos;main(ReturnsExample.java:21)&apos; could not be determined automatically, due to type erasure. You can give type information hints by using the returns(...) method on the result of the transformation call, or by letting your function implement the &apos;ResultTypeQueryable&apos; interface.</span><br><span class="line">	at org.apache.flink.api.dag.Transformation.getOutputType(Transformation.java:479)</span><br><span class="line">	at org.apache.flink.streaming.api.datastream.DataStream.addSink(DataStream.java:1236)</span><br><span class="line">	at org.apache.flink.streaming.api.datastream.DataStream.print(DataStream.java:937)</span><br><span class="line">...</span><br><span class="line">Caused by: org.apache.flink.api.common.functions.InvalidTypesException: The generic type parameters of &apos;Tuple2&apos; are missing. In many cases lambda methods don&apos;t provide enough information for automatic type extraction when Java generics are involved. An easy workaround is to use an (anonymous) class instead that implements the &apos;org.apache.flink.api.common.functions.MapFunction&apos; interface. Otherwise the type has to be specified explicitly using type information.</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>此外，在某些情况下，Flink 选择的 TypeInformation 可能无法生成最有效的序列化器和反序列化器。因此，你可能需要为你使用的数据类型显式地提供 TypeInformation。我们首先看一下如何创建 TypeInformation，然后再看一下如何为函数指定 TypeInformation。</p>
<h2 id="3-1-创建-TypeInformation"><a href="#3-1-创建-TypeInformation" class="headerlink" title="3.1 创建 TypeInformation"></a>3.1 创建 TypeInformation</h2><h4 id="3-1-1-of-方法"><a href="#3-1-1-of-方法" class="headerlink" title="3.1.1 of 方法"></a>3.1.1 of 方法</h4><p>对于非泛型的类型，可以使用 TypeInformation 的 of(Class<t> typeClass) 函数直接传入 Class 就可以创建 TypeInformation：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例1 非泛型类型 直接传入 Class 对象</span></span><br><span class="line">DataStream&lt;WordCount&gt; result1 = env.fromElements(<span class="string">"a b a"</span>)</span><br><span class="line">        .flatMap((String value, Collector&lt;WordCount&gt; out) -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span>(String word : value.split(<span class="string">"\\s"</span>)) &#123;</span><br><span class="line">                out.collect(<span class="keyword">new</span> WordCount(word, <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .returns(TypeInformation.of(WordCount.class));</span><br><span class="line">result1.print(<span class="string">"R1"</span>);</span><br></pre></td></tr></table></figure></t></p>
<p>上述方法仅适用于非泛型类型。如果是泛型类型，可以借助 TypeHint 为泛型类型创建 TypeInformation：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例2 泛型类型 需要借助 TypeHint</span></span><br><span class="line">DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; result2 = env.fromElements(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>)</span><br><span class="line">        .map(value -&gt; Tuple2.of(value, <span class="number">1</span>))</span><br><span class="line">        .returns(TypeInformation.of(<span class="keyword">new</span> TypeHint&lt;Tuple2&lt;String, Integer&gt;&gt;() &#123;&#125;));</span><br><span class="line">result2.print(<span class="string">"R2"</span>);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><a href="https://github.com/sjf0115/data-example/blob/master/flink-example/src/main/java/com/flink/example/stream/base/typeInformation/hints/TypeInformationOfExample.java" target="_blank" rel="noopener">完整示例</a></p>
</blockquote>
<h4 id="3-1-2-TypeHint"><a href="#3-1-2-TypeHint" class="headerlink" title="3.1.2 TypeHint"></a>3.1.2 TypeHint</h4><p>对于泛型类型，上面是通过 TypeInformation.of + TypeHint 来创建 TypeInformation，也可以单独使用 TypeHint 来创建 TypeInformation：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; result2 = env.fromElements(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>)</span><br><span class="line">        .map(value -&gt; Tuple2.of(value, <span class="number">1</span>))</span><br><span class="line">        .returns(<span class="keyword">new</span> TypeHint&lt;Tuple2&lt;String, Integer&gt;&gt;() &#123;&#125;.getTypeInfo());</span><br><span class="line">result2.print(<span class="string">"R2"</span>);</span><br></pre></td></tr></table></figure></p>
<p>TypeHint 的原理是在内部创建匿名子类，捕获泛型信息并会将其保留到运行时。运行时 TypeExtractor 可以获取保存的实际类型。</p>
<blockquote>
<p><a href="https://github.com/sjf0115/data-example/blob/master/flink-example/src/main/java/com/flink/example/stream/base/typeInformation/hints/TypeHintExample.java" target="_blank" rel="noopener">完整示例</a></p>
</blockquote>
<h4 id="3-1-3-预定义的快捷方式"><a href="#3-1-3-预定义的快捷方式" class="headerlink" title="3.1.3 预定义的快捷方式"></a>3.1.3 预定义的快捷方式</h4><p>例如 BasicTypeInfo 类定义了一系列常用类型的快捷方式，对于 String、Boolean、Byte、Short、Integer、Long、Float、Double、Char 等基本类型的类型声明，可以直接使用：</p>
<p><img src="https://github.com/sjf0115/ImageBucket/blob/main/Flink/flink-datastream-typeinformation-3.png?raw=true" alt=""></p>
<p>当然，如果觉得 BasicTypeInfo 还是太长，Flink 还提供了完全等价的 Types 类（org.apache.flink.api.common.typeinfo.Types）：</p>
<p><img src="https://github.com/sjf0115/ImageBucket/blob/main/Flink/flink-datastream-typeinformation-4.png?raw=true" alt=""></p>
<p>Types 为常见数据类型提供 TypeInformation，使用起来非常方便，如下示例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例1 Types.TUPLE</span></span><br><span class="line">DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; result1 = env.fromElements(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>)</span><br><span class="line">        .map(value -&gt; Tuple2.of(value, <span class="number">1</span>))</span><br><span class="line">        .returns(Types.TUPLE(Types.STRING, Types.INT));</span><br><span class="line">result1.print(<span class="string">"R1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2 Types.POJO</span></span><br><span class="line">DataStream&lt;WordCount&gt; result2 = env.fromElements(<span class="string">"a b a"</span>)</span><br><span class="line">        .flatMap((String value, Collector&lt;WordCount&gt; out) -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span>(String word : value.split(<span class="string">"\\s"</span>)) &#123;</span><br><span class="line">                out.collect(<span class="keyword">new</span> WordCount(word, <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .returns(Types.POJO(WordCount.class));</span><br><span class="line">result2.print(<span class="string">"R2"</span>);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><a href="https://github.com/sjf0115/data-example/blob/master/flink-example/src/main/java/com/flink/example/stream/base/typeInformation/hints/TypesExample.java" target="_blank" rel="noopener">完整示例</a></p>
</blockquote>
<h3 id="3-2-显示提供类型信息"><a href="#3-2-显示提供类型信息" class="headerlink" title="3.2 显示提供类型信息"></a>3.2 显示提供类型信息</h3><p>当 Flink 无法自动推断函数的生成类型是什么的时候，就需要我们显示提供类型信息提示。从上面示例中我们知道可以通过 returns 显示提供类型信息，除此之外还可以实现 ResultTypeQueryable 接口显示提供。</p>
<h4 id="3-2-1-returns"><a href="#3-2-1-returns" class="headerlink" title="3.2.1 returns"></a>3.2.1 returns</h4><p>第一种方法是使用 returns 为算子添加返回类型的类型信息提示。对于非泛型类型，可以直接传入 Class 即可；对于泛型类型需要借助 TypeHint 提供类型信息提示，如下所示：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例1 非泛型类型 直接传入 Class</span></span><br><span class="line">DataStream&lt;WordCount&gt; result1 = env.fromElements(<span class="string">"a b a"</span>)</span><br><span class="line">        .flatMap((String value, Collector&lt;WordCount&gt; out) -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span>(String word : value.split(<span class="string">"\\s"</span>)) &#123;</span><br><span class="line">                out.collect(<span class="keyword">new</span> WordCount(word, <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .returns(WordCount.class);</span><br><span class="line">result1.print(<span class="string">"R1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2 泛型类型 优先推荐借助 TypeHint</span></span><br><span class="line">DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; result2 = env.fromElements(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>)</span><br><span class="line">        .map(value -&gt; Tuple2.of(value, <span class="number">1</span>))</span><br><span class="line">        .returns(<span class="keyword">new</span> TypeHint&lt;Tuple2&lt;String, Integer&gt;&gt;() &#123;&#125;);</span><br><span class="line">result2.print(<span class="string">"R2"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例3 TypeInformation.of + TypeHint</span></span><br><span class="line">DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; result3 = env.fromElements(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>)</span><br><span class="line">        .map(value -&gt; Tuple2.of(value, <span class="number">1</span>))</span><br><span class="line">        .returns(TypeInformation.of(<span class="keyword">new</span> TypeHint&lt;Tuple2&lt;String, Integer&gt;&gt;() &#123;&#125;));</span><br><span class="line">result3.print(<span class="string">"R3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例4 Types 快捷方式</span></span><br><span class="line">DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; result4 = env.fromElements(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>)</span><br><span class="line">        .map(value -&gt; Tuple2.of(value, <span class="number">1</span>))</span><br><span class="line">        .returns(Types.TUPLE(Types.STRING, Types.INT));</span><br><span class="line">result4.print(<span class="string">"R4"</span>);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><a href="https://github.com/sjf0115/data-example/blob/master/flink-example/src/main/java/com/flink/example/stream/base/typeInformation/hints/ReturnsExample.java" target="_blank" rel="noopener">完整示例</a></p>
</blockquote>
<h4 id="3-2-2-ResultTypeQueryable"><a href="#3-2-2-ResultTypeQueryable" class="headerlink" title="3.2.2 ResultTypeQueryable"></a>3.2.2 ResultTypeQueryable</h4><p>第二种方法是通过实现 ResultTypeQueryable 接口来扩展函数以显式提供返回类型的 TypeInformation。如下示例是一个显式提供返回类型的 MapFunction：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultTypeMapFunction</span> <span class="keyword">implements</span> <span class="title">MapFunction</span>&lt;<span class="title">String</span>, <span class="title">Stu</span>&gt;, <span class="title">ResultTypeQueryable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Stu <span class="title">map</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String[] params = value.split(<span class="string">","</span>);</span><br><span class="line">        String name = params[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> age = Integer.parseInt(params[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Stu(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TypeInformation <span class="title">getProducedType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Types.POJO(Stu.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a>4. 使用场景</h2><h3 id="4-1-Table-转-DataStream"><a href="#4-1-Table-转-DataStream" class="headerlink" title="4.1 Table 转 DataStream"></a>4.1 Table 转 DataStream</h3><p>Table 转 DataStream 的时候，Table 并清楚 DataStream 的数据结构，因此需要给当前转换出来的 DataStream 显性的指定数据类型：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转化为 Pojo 类型</span></span><br><span class="line">DataStream&lt;WordCount&gt; stream1 = tEnv.toAppendStream(table, Types.POJO(WordCount.class));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为 Row 类型</span></span><br><span class="line">DataStream&lt;Row&gt; stream2 = tEnv.toAppendStream(table, Types.ROW(Types.STRING, Types.LONG));</span><br></pre></td></tr></table></figure></p>
<h3 id="4-2-Lambda-表达式与泛型"><a href="#4-2-Lambda-表达式与泛型" class="headerlink" title="4.2 Lambda 表达式与泛型"></a>4.2 Lambda 表达式与泛型</h3><p>由于 Java 泛型会出现类型擦除问题，因此 Flink 通过 Java 反射机制尽可能重构类型信息，例如使用函数签名以及子类的信息等。对于函数的返回类型取决于输入类型的情况时，会包含一些简单的类型推断。但如果无法重构所有的泛型类型信息时，需要借助于类型提示来告诉系统函数中传入的参数类型信息和输出参数信息。如下所示使用 returns 语句指定生成的类型：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">env.fromElements(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">  .map(i -&gt; Tuple2.of(i, i*i))</span><br><span class="line">  <span class="comment">// 如果不指定 returns 返回的 TypeInformation 会抛出异常</span></span><br><span class="line">  .returns(Types.TUPLE(Types.INT, Types.INT))</span><br><span class="line">  .print();</span><br></pre></td></tr></table></figure></p>
<p>参考：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/FziI1YyaccuRLQAURWLnUw" target="_blank" rel="noopener">Apache Flink 进阶（五）：数据类型和序列化</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1240444" target="_blank" rel="noopener">Flink 类型和序列化机制简介</a></li>
</ul>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>赏几毛白！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="sjf0115 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.png" alt="sjf0115 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    smartsi
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://smartsi.club/flink-datastream-typeinformation.html" title="Flink DataStream 类型系统 TypeInformation">http://smartsi.club/flink-datastream-typeinformation.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Flink/" rel="tag"># Flink</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/apache-seatunnel-introduction.html" rel="next" title="Apache SeaTunnel 分布式数据集成平台">
                <i class="fa fa-chevron-left"></i> Apache SeaTunnel 分布式数据集成平台
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/flink-table-api-sql-common-api.html" rel="prev" title="Flink Table API & SQL 基本操作">
                Flink Table API & SQL 基本操作 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMjQ2MS85MDIy"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/header.png"
                alt="sjf0115" />
            
              <p class="site-author-name" itemprop="name">sjf0115</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">316</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    <span class="site-state-item-count">42</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    <span class="site-state-item-count">64</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/sjf0115" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1203745031@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://blog.csdn.net/sunnyyoona" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-globe"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://blog.csdn.net/sunnyyoona" title="CSDN" target="_blank">CSDN</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://theme-next.iissnan.com" title="NexT主题" target="_blank">NexT主题</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-数据类型"><span class="nav-number">1.</span> <span class="nav-text">1. 数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-基本类型"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 基本类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-数组类型"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 数组类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-复合数据类型"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 复合数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-Java-Tuples-类型"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.3.1 Java Tuples 类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-Scala-Case-Class-与-Tuple-类型"><span class="nav-number">1.3.2.</span> <span class="nav-text">1.3.2 Scala Case Class 与 Tuple 类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-3-ROW-类型"><span class="nav-number">1.3.3.</span> <span class="nav-text">1.3.3 ROW 类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-4-POJO-类型"><span class="nav-number">1.3.4.</span> <span class="nav-text">1.3.4 POJO 类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-辅助类型"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 辅助类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-泛型类型"><span class="nav-number">1.5.</span> <span class="nav-text">1.5 泛型类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-TypeInformation"><span class="nav-number">2.</span> <span class="nav-text">2. TypeInformation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-显示指定-TypeInformation"><span class="nav-number">3.</span> <span class="nav-text">3. 显示指定 TypeInformation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-创建-TypeInformation"><span class="nav-number">4.</span> <span class="nav-text">3.1 创建 TypeInformation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-of-方法"><span class="nav-number">4.0.1.</span> <span class="nav-text">3.1.1 of 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-TypeHint"><span class="nav-number">4.0.2.</span> <span class="nav-text">3.1.2 TypeHint</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-预定义的快捷方式"><span class="nav-number">4.0.3.</span> <span class="nav-text">3.1.3 预定义的快捷方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-显示提供类型信息"><span class="nav-number">4.1.</span> <span class="nav-text">3.2 显示提供类型信息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-returns"><span class="nav-number">4.1.1.</span> <span class="nav-text">3.2.1 returns</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-ResultTypeQueryable"><span class="nav-number">4.1.2.</span> <span class="nav-text">3.2.2 ResultTypeQueryable</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-使用场景"><span class="nav-number">5.</span> <span class="nav-text">4. 使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-Table-转-DataStream"><span class="nav-number">5.1.</span> <span class="nav-text">4.1 Table 转 DataStream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-Lambda-表达式与泛型"><span class="nav-number">5.2.</span> <span class="nav-text">4.2 Lambda 表达式与泛型</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sjf0115</span>

  

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Mist</a> v6.0.1</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-eye"></i> 本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.1"></script>



  



	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  








  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'TU3U2HXdoBxlVVD4YGMbe6Ye-gzGzoHsz',
        appKey: 'MsfAHet79NrOIrFB82biqYDx',
        placeholder: '有什么问题，欢迎留言指正与交流...',
        avatar:'robohash',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("TU3U2HXdoBxlVVD4YGMbe6Ye-gzGzoHsz", "MsfAHet79NrOIrFB82biqYDx");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  


  

  

</body>
</html>
